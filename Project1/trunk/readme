/* CPSC545 Spring2011 Project 1
* login: masuij(login used to submit)
* Linux
* date: 03/28/11
* name: Justin Masui, Pichai Assawaruangchai, Quy Le
* emails: veks11@gmail.com,assawaru@seattleu.edu,quyvle@gmail.com */

####################################
 The purpose of your program
####################################
The program graphexec will be responsible for analyzing a graph of user programs, determining which ones are eligible to run, and running programs
that are eligible to run at that moment in time. As programs in the graph finish, your program will determine which other programs in the graph have become eligible to run, execute those programs, and continue this process until all programs are finished.

####################################
 How to compile the program
####################################

To compile:
make clean
make  //note that this creates 

To clean:

####################################
 How to use the program from the shell (syntax)
####################################


####################################
 What exactly your program does
####################################  
Basic idea is that each node's information is added ot the following maps

name            key     value
--------------- ---     --------------------
allNodesMap     id      node
numParents      id      numParents
 
-  if numParents[id]=0, then the node is added to ready queue. 
-  when each node completes execution, for each element in allNodesMap[id].children the numParents[child] is decremented 1.  If this value is equal to 0 then move to ready queue.
-  execute all jobs in ready queue, move running jobs to finishq
-  repeat until all jobs in finishq

This gives an O(V+E) because populating the numParents is O(V+E).  Otherwise, every other operation is O(V).  This is equivalent complexity to a Topological sort, but unlike topological support it allows for execution parallelism in the process dependencies.
